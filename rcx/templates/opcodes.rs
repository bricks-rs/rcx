// This file is automatically generated

{% for opcode in opcodes %}
#[doc=r#"{{ opcode.description }}"#]
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct {{ opcode.name }} {
    {% for param in opcode.request.params %}
    pub {{ param.name }}: {{ param.ty }},
    {% endfor %}
}

impl Opcode for {{ opcode.name }} {
    fn request_opcode(&self) -> u8 {
        {{ opcode.request.opcode|hex }}
    }

    fn response_opcode(&self) -> Option<u8> {
    {% if let Some(response) = opcode.response %}
        Some({{ response.opcode|hex}})
    {% else %}
        None
    {% endif %}
    }

    fn serialise(&self, buf: &mut [u8]) -> Result<usize> {
        #[allow(unused_mut)]
        let mut cursor = Cursor::new(buf);
        {% for param in opcode.request.params %}
        self.{{ param.name }}.write_param(&mut cursor)?;
        {% endfor %}
        Ok(cursor.position().try_into()?)
    }

    #[allow(unreachable_code)]
    fn disasm(i: &[u8]) -> IResult<&[u8], Self> {
        {% for param in opcode.request.params %}
        let (i, {{ param.name }}) =
            {% if param.ty == "Vec<u8>" %}
            unimplemented!();
            {% else %}
            <{{ param.ty }} as DisasmParam>::disasm_param(i)?;
            {% endif %}
        {% endfor %}

        Ok((i, Self {
            {% for param in opcode.request.params %}
            {{ param.name }},
            {% endfor %}
        }))
    }
}


{% if let Some(response) = opcode.response %}
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct {{ opcode.name }}Response {
    {% for param in response.params %}
    pub {{ param.name }}: {{ param.ty }},
    {% endfor %}
}

impl {{ opcode.name }}Response {
    pub fn deserialise(buf: &[u8]) -> Result<Self> {
        let mut cursor = Cursor::new(buf);

        // skip header bytes
        loop {
            let mut byte=[0];
            cursor.read_exact(&mut byte)?;
            if !is_header(byte[0]) {
                cursor.seek(SeekFrom::Current(-1))?;
                break;
            }
        }

        // read & verify opcode
        let opcode = u8::read_param(&mut cursor)?;

        // not every opcode will write to the checksum
        #[allow(unused_mut)]
        let mut checksum = opcode;

        // parse out fields
        {% for param in response.params %}
        let {{ param.name }} =
            <{{ param.ty }} as ReadParam>::read_param(&mut cursor)?;
        {{ param.name }}.add_to_checksum(&mut checksum);
        {% endfor %}

        // validate checksum
        let pkt_checksum = u8::read_param(&mut cursor)?;

        if checksum == pkt_checksum {
            Ok(Self {
                {% for param in response.params %}
                {{ param.name }},
                {% endfor %}
            })
        } else {
            Err(Error::Checksum)
        }
    }
}
{% endif %}

impl Display for {{ opcode.name }} {
    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {
        write!(fmt, "{{ opcode.name }}")?;
        {% for param in opcode.request.params %}
        write!(fmt, " {{ param.name }}={:02x?}", self.{{ param.name }})?;
        {% endfor %}
        Ok(())
    }
}

{% endfor %}

fn dynify((i, code): (&[u8], impl Opcode + 'static)) -> (&[u8], Box<dyn Opcode>)
{
    (i, Box::new(code))
}

pub fn parse_opcode(i: &[u8]) -> IResult<&[u8], Box<dyn Opcode>> {
    let (i, code) = nom::number::complete::u8(i)?;
    match code {
        {% for opcode in opcodes %}
        {{ opcode.request.opcode|hex }} =>
            Ok(dynify({{ opcode.name }}::disasm(i)?)),
        {% endfor %}
        other => Err(nom::Err::Failure(nom::error::Error {
            input: i,
            code: nom::error::ErrorKind::Fail,
        })),
    }
}